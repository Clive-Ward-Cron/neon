import domtoimage from "dom-to-image-more";
import { getComputedStyleObject, wrapIfTextNode } from "./utils";

export function makeImage(e) {
  // Make an image out of the slotted node and assign it as the background image
  if (this.shadowRoot.querySelector("slot").assignedNodes().length > 0) {
    // pass the slots first child to wrapIfTextNode
    // If its a text node it will be returned wrapped in a span,
    // Otherwise it returns the unmodified element node.
    const el = wrapIfTextNode.bind(this)(e.target.assignedNodes()[0]);

    // The Element needs to be visible to create an image of it
    if (el.style.opacity === "0") {
      el.style.opacity = 1;
    }

    // Get the width and height from the bounding client rect and get an integer instead of float
    const rect = el?.getBoundingClientRect ? el.getBoundingClientRect() : this.getBoundingClientRect();
    const rectWidth = Math.ceil(rect.width);
    const rectHeight = Math.ceil(rect.height);
    const elStyles = getComputedStyleObject(el);

    // Need to declare a set of default styles to overwrite the
    // ones that are generated by domtoimage that cause issues.
    // ! Need to use Bracket Accessor to overwrite the properties properly
    const overwrite = {};
    overwrite["margin-block"] = "0"; // margins were applied in the SVG
    overwrite["white-space"] = "nowrap"; // Fixes unwanted text nodes wrapping

    // User will have to figure their own font compensation amount
    const compensation = this.fontCompensation;

    domtoimage
      .toSvg(el, {
        width:
          rectWidth +
          parseInt(elStyles.marginRight.replace("px")) +
          parseInt(elStyles.marginLeft.replace("px")) +
          compensation,
        height: rectHeight,
        style: Object.assign(elStyles, overwrite),
      })
      .then((dataURL) => {
        // TODO: Look into finding a way to do this in the dom-to-image-more
        // Set the returned SVG data as the background image
        this.src = dataURL.replace(/<style>@font-face.*<\/style>/, "").replace(/%0A/g, "");
        // Adjust the width and height of the component
        // or the returned image won't display
        this.width =
          rectWidth + parseInt(elStyles.marginRight.replace("px")) + parseInt(elStyles.marginLeft.replace("px")) + "px";
        this.height =
          rectHeight +
          parseInt(elStyles.marginTop.replace("px")) +
          parseInt(elStyles.marginBottom.replace("px")) +
          "px";

        // Don't display the original slotted element
        // or there will be an ugly overlay
        el.style.opacity = 0;
      });
  }
}
