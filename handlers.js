import domtoimage from "dom-to-image-more";
import { getComputedStyleObject, wrapIfTextNode } from "./utils";
// const domtoimage = require("dom-to-image-more");

export function makeImage(e) {
  // pass the slots first child to wrapIfTextNode
  // If its a text node it will be returned wrapped in a span,
  // Otherwise it returns the unmodified element node.
  const el = wrapIfTextNode.bind(this)(e.target.assignedNodes()[0]);

  // Get the width and height from the bounding client rect and get an integer instead of float
  const rect = el?.getBoundingClientRect ? el.getBoundingClientRect() : this.getBoundingClientRect();
  const rectWidth = Math.ceil(rect.width);
  const rectHeight = Math.ceil(rect.height);

  // Make an image out of the slotted node and assign it as the background image
  if (this.shadowRoot.querySelector("slot").assignedNodes().length > 0) {
    // Need to declare a set of default styles to overwrite the
    // ones that are generated by domtoimage that cause issues.
    // ! Need to use Bracket Accessor to overwrite the properties properly
    const overwrite = {};
    overwrite["margin-block"] = "0"; // margins were applied in the SVG
    overwrite["margin"] = "0";
    overwrite["white-space"] = "nowrap"; // Fixes unwanted text nodes wrapping

    const tempFix = 5; // Temporary fix for font sidebearing issue

    domtoimage
      .toSvg(el, {
        width: rectWidth + tempFix,
        height: rectHeight,
        style: Object.assign(getComputedStyleObject(el), overwrite),
      })
      .then((dataURL) => {
        // Set the returned SVG data as the background image
        this.src = dataURL;
        // Adjust the width and height of the component
        // or the returned image won't display
        this.width = rectWidth + "px";
        this.height = rectHeight + "px";

        // Don't display the original slotted element
        // or there will be an ugly overlay
        el.style.display = "none";
      });
  }
}
